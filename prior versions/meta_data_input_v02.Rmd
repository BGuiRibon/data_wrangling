---
title: "R Notebook"
output: html_notebook
---

```{r include=FALSE}
require("tidyverse")
```

Top issues in R so far
- not understanding the difference between calling a function with an object vs subsetting of an object
- using () vs [] at the right time
- messing up placement of () and [] in nested expression
- understanding the help files
- not understanding what type of input is needed for a function
- not understanding the type of output a certain function gives

biggest friends so far in contrast to coding a long time back:
- stepping through code line-by-line
- looking at evolution of variables at every single step
- seemless stepping between notebook vs. console



```{r include=FALSE}



```

Summary and requirements:

This script takes a CSV file from Excel or another similar program containing metadata of experiments and converts it semi-automatically to a long dataframe suitable to receive output from virtually any other instrument that puts the data on a per-plate basis either into a single table or a row/column format. This script only deals with the metadata. 'raw_data_input' deals with the experimental results. A third script 'meta_raw_merge' combines the two and performs some basic QC. The thought is that the output from that script is ready for deeper analysis, plotting of results, extracting data for other experiments, ...

MetaData requirements:

The file contains two parts: Plate-level data first and Well-level data second. For now only 384 well plates are supported, but the script should be easily adjustable for 96 well plates or any other plate-based format.

Plate-level data:

- A table with columns for variables/attributes with one row for each physical plate used in the experiment.
- One column needs to be labeled 'Experiment_ID' and must contain a unique ID in each row. Best practices take the date of 'day0' of the experiment and append your initials. For an experiment I started on April 16th 2019 the ID would be "20190416_MN"
- One column needs to contain unique plate IDs that should not overlap with any other experiments in case results will letter be merged. Best practices are to simply take the experiment ID and append _01, _02, ...This way there will be no overlap. 
- Each entry has to be a complete column and contain a header and one entry for each plate. Missing values will create ambiguities when addressing the data later and can not be tolerated

Well-level data:
- each well-level treatment needs a complete 'block' of information made of two parts. Variable information for the type of treatment and qualitative or quantitative information about the treatment for each well
- the type of treatment has to be a block of four entries:

variable   | type
-----------+------------    
descriptor | attribute

"variable" needs to be entered for the script to recognize a new column
type needs to be entered as "numeric" or "factor" to designate if there is a continuous variable or not
descriptor denotes a treatment class that makes sense (e.g. drug, cytokine, media, gRNA, cell_no, ...)
if a given descriptor has multiple attributes they are combined with the descriptors. For all descriptors the most basic attribute should be ID. Additional ones for a drug could be: concentration, the vehicle, and treatment time. This would give drug_ID, drug_conc, drug_vehicle, and drug_treattime. And each one of these variables would get their own block of row/column entries.

- the qualitative/quantitative block for each variable needs to be regular and complete (no empty cells in 16 rows x 24 columns). Empty cells can be filled either with NA, NULL, NaN, or whatever other label makes sense to you. The dataframe will contain these entries as it is being assembled, but they can easily be filtered out later. 





```{r}
# Import of CSV data

# user input of which file to load
# assign unique experiment ID
# should be included in every plot generated by the script to link output to script and data

setwd("C:/Users/mario/OneDrive - Ribon Therapeutics/R projects/data wrangling")
input_file <- "Bin_metadata"

suppressMessages(meta <- read_csv(paste0(input_file,".csv"), col_names = FALSE))

# remove all NA rows and columns

meta <- meta[rowSums(is.na(meta)) != ncol(meta),]
meta <- meta[,colSums(is.na(meta)) != nrow(meta)]


# Validate the presence of Experiment_ID and Plate_ID

if (length(which(meta=="Experiment_ID"))==0) {
     stop("Experiment_ID not found. Please fix input.")
}

if (length(which(meta=="Plate_ID"))==0) {
     stop("Plate_ID not found. Please fix input.")
}


```





```{r}
# separate meta into meta data for plates and wells

# identify entry with 'Experiment_ID'

row <- which(meta=="Experiment_ID", arr.ind = T)[1]
col <- which(meta=="Experiment_ID", arr.ind = T)[2]

# set name of Experiment_ID
Experiment_ID <- toString(meta[row+1,col])


# subset all rows of meta that contain "experiment ID" 
# %in% checks the resulting evaluation of "(meta[,col] == "Experiment_ID" | meta[,col] == Experiment_ID)" and tests if it is TRUE
plates <- meta[(meta[,col] == "Experiment_ID" | meta[,col] == Experiment_ID) %in% TRUE, ]

# subset all rows of meta with the logical inverse of plates
wells <- meta[!((meta[,col] == "Experiment_ID" | meta[,col] == Experiment_ID) %in% TRUE),]


```


```{r}
# clean up and sanity check for plates 

# remove NA columns as above
plates <- plates[,colSums(is.na(plates)) != nrow(plates)]

# check for presence of any NA in rows
# rowSums(is.na(plates)) counts NAs per row and puts out a vector
# sum(rowSums) takes the sum of that
# if this is not zero there has to be an NA somewhere
if (sum(rowSums(is.na(plates))) > 0) {
     stop("Plate annotation is incomplete. Missing values can't be interpreted.")
}

# convert first row into names and remove that row
colnames(plates) <- as.character(unlist(plates[1,]))
plates <- plates[-1,]

# Set up Experiment_ID level and Plate_ID

# check that there is only one entry in Experiment_ID
if (n_distinct(plates$Experiment_ID)!=1) {
     stop("Experiment_ID is not identical across all plates.")
}

# set up experiment_level dataframe and remove from plates
exp_level <- data.frame(Experiment_ID=plates$Experiment_ID)
plates <- plates[ , !(names(plates)=="Experiment_ID")]


# check that there are nrow entries in Experiment_ID
if (n_distinct(plates$Plate_ID)!=nrow(plates)) {
     stop("Plate_ID is not unique across all plates.")
}

# set up plate_level dataframe and remove from plates
plate_level <- data.frame(Plate_ID=plates$Plate_ID) 
plates <- plates[ , !(names(plates)=="Plate_ID")]


```



```{r}
# parse the plates section
# place all unique cols into exp- and the rest into plate-level







```


```{r}

# --- custom functions ---------------------------------------

ColQuery <- function(prompt) {     
     x = ncol(plates)+1
     while (cols_assigned[x]==TRUE | x > ncol(plates)) {
          x <- as.integer(readline(prompt))
          if(is.na(x)) x=match(FALSE, cols_assigned) # NA means first free column is selected
          if(x < 1) x=ncol(plates)+1
     }
     return(x)
}

# --- custom functions ---------------------------------------




# figure out which column has the plate ID
q <- ColQuery("Which column holds the unique plate ID: ")
plate_level <- data.frame(Plate_ID=plates$Plate_ID)   
colnames(plates)[q]="PLATE_LEVEL_Plate_ID"
cols_assigned[q]=TRUE

# check if all items in Plate ID are unique
# unique(plates$ASSIGNED_Plate_ID) returns vector with unique items
# length of vector needs to be number of rows in plates
if (length(unique(plates$PLATE_LEVEL_Plate_ID)) != nrow(plates)) {
     stop("All Plate_ID values have to be unique to avoid ambiguity.")
}

# ------------------------------------------------------------------------------------


# define logical vector to keep track of which column is assigned by what 
cols_assigned <- as.logical(c(rep(FALSE, ncol(plates)), TRUE))

# display plates to see columns
View(plates)
View(plate_level)
view(exp_level)


# input number of experiment-level variables
q <- -1
while (q < 0 | q > length(cols_assigned[cols_assigned==FALSE])) {
     q <- as.integer(readline("Number of experiment-level variables: "))
     if(is.na(q)) (q=0)
}
n <- q

# loop to assign variable name to column with values
q <- ncol(plates)+1
while (n != 0) {
     while (n !=0 & cols_assigned[q]==TRUE) {
          q <- ColQuery(paste("Column with experiment-level variable (", n, "): "))                 # q holds the col number to be assigned
          name <- as.character(readline("Name: "))                                                  # vector of exp_level being filled with new name
          if (name == "") { name <- colnames(plates)[q] }                                           # is new name is empty, replace with col name
          exp_level <- cbind(exp_level, plates[ ,q])
          colnames(exp_level)[ncol(exp_level)] <- name
          colnames(plates)[q] <- paste0("EXP_LEVEL_", name)                                         # paste EXP_LEVEL to colnames
          cols_assigned[q] <- TRUE                                                                  # assign q value TRUE to mark it assigned
          q <- ncol(plates)+1                                                                       # q to be set onto FALSE as default
          n <- n-1                                                                                  # count n down by 1
     }
}



# ------------------------------------------------------------------------------------

# input number of plate-level variables
q <- -1
while (q < 0 | q > length(cols_assigned[cols_assigned==FALSE])) {
     q <- as.integer(readline("Number of plate-level variables: "))
     if (is.na(q)) (q=0)
}
n <- q

# loop to assign variable name to column with values
q <- ncol(plates)+1
while (n != 0) {
     while (n !=0 & cols_assigned[q]==TRUE) {
          q <- ColQuery(paste("Column with plate-level variable (", n, "): "))                      # q holds the col number to be assigned
          name <- as.character(readline("Name: "))                                                  # vector of exp_level being filled with new name
          if (name == "") { name <- colnames(plates)[q] }                                           # is new name is empty, replace with col name
          plate_level <- cbind(plate_level, plates[ ,q])
          colnames(plate_level)[ncol(plate_level)] <- name
          colnames(plates)[q] <- paste0("PLATE_LEVEL_", name)                                       # paste EXP_LEVEL to colnames
          cols_assigned[q] <- TRUE                                                                  # assign q value TRUE to mark it assigned
          q <- ncol(plates)+1                                                                       # q to be set onto FALSE as default
          n <- n-1                                                                                  # count n down by 1
     }
}


# # create and insert Plate_No column
plate_level$Plate_No <- as.integer(1:nrow(plates)) 
plate_level <- plate_level[ , c(1, ncol(plate_level), 2:(ncol(plate_level)-1))]

# 
# print(as.tibble(plates))
# print(as.tibble(exp_level))
# print(as.tibble(plate_level))
# 


```


```{r}
# clean up the plate map data and convert into a dataframe

# identify positions of "variable"
variables <- data.frame(which(wells=="variable", arr.ind=TRUE))       # identify x/y of 'variables' 
variables <- variables[order(variables$row),]                         # sort variables table by row


# set up complete dataframe with additional Plate columns
# p_row <- rep(LETTERS[seq(1:16)],24)
# p_col <- trunc((seq(1:384)+15)/16)
# w_no <- seq(1:384)
# 
# print(p_row)
# print(p_col)
# print(w_no)

well_level <- data.frame(Plate_Row = (rep(LETTERS[seq(1:16)],24)), Plate_Col = trunc((seq(1:384)+15)/16), Well_No = seq(1:384))

# add column for Well_name (A01-P24)
# Well_Name is concatenation of Plate_Row and Plate_Col
# str_pad adds a leading character ("0") to width (2)

well_level <- well_level %>% 
     mutate(Well_Name = paste0(Plate_Row, str_pad(Plate_Col, 2, pad = "0"))) %>%

# sort by well number
     arrange(Well_No)

```


```{r}


# join 384 row well_level info with readouts


end_row <- 0
for (i in 1:nrow(variables)) {                                   

# empty out dataframe
     slice <- data.frame()
          
# put row/col value of current plate map in row and col
     row <- variables[i,"row"]
     col <- variables[i,"col"]
  
     
# identify variable type, names, and attribute
     type <- wells[row, col+1]
     name <- wells[row+1, col]
     attribute <- wells[row+1, col+1]

# slice out plate based on location of 'variables'
     if  ( i==nrow(variables) ) ( end_row <- nrow(wells) ) else ( end_row <- variables[i+1,"row"]-1 )
     slice <- wells %>% slice((row+2):end_row)

# remove NA rows and NA columns
     slice <- slice[rowSums(is.na(slice)) != ncol(slice),] # remove cols of all NA
     slice <- slice[,colSums(is.na(slice)) != nrow(slice)] # remove rows of all NA     

     values <- unlist(slice, use.names = F)
 #    length(values)

# append column to well_level dataframe
     if (type=="numeric") { 
               well_level <- cbind(well_level, as.numeric(values))
          } else {
               well_level <- cbind(well_level, values)
     }
# add proper metadata heading to new df column 'Name_Attribute' e.g drug_id
     names(well_level)[ncol(well_level)] <- paste0(name,"_",attribute)
}

# extract level variables
well_level_names <- c(colnames(well_level[5:ncol(well_level)]))
plate_level_names <- c(colnames(plate_level[]))
exp_level_names <- c(colnames(exp_level[])) 

```



```{r}

# assemble the full data frame from plate info and plate maps

# join experiment and plate-level metadata
# Duplicate each row in plates 384x
# lastly reorder the file by plate No 
exp_plate_level <- cbind(exp_level, plate_level) %>% slice(rep(row_number(), 384)) %>% arrange(Plate_No)


# combine wells_long and plates_long
meta_processed <- cbind(exp_plate_level, well_level)

# sort by plate and well number
# give proper row names to complete file

meta_processed <- arrange(meta_processed, Plate_No, Plate_Col)

rownames(meta_processed) <- c(seq(1:nrow(meta_processed)))


# rearrange columns by using relocate
# go via creation of 'new order' vector in case exp_level or plate_level is empty
# this causes dplyr to throw an error
new_order <- c("Experiment_ID", "Plate_ID", "Plate_No", "Plate_Row", "Plate_Col", "Well_Name", "Well_No", exp_level_names, plate_level_names) 

meta_processed <- meta_processed %>% relocate (new_order[]) 






```


```{r}
# data summary
# When you have the time, redo with cat() and writeLines()
# nest summary properly for displaying unique variables by attribute when calling out the attribute



print("--- EXPERIMENT LEVEL SUMMARY -----------------------------------------------------------------------")
if (length(exp_level)==0) {
     (paste0("No experiment-level variables."))
     } else {
     print(paste0("Experiment-level variables (", length(exp_level_names), "): ", paste(exp_level_names, collapse=", "))) 
     print("Unique variable at experiment-level: ")
     print(meta_processed %>% select(all_of(exp_level_names)) %>% lapply(unique) )
}
     
print("--- PLATE LEVEL SUMMARY -----------------------------------------------------------------------------")
print(paste0("Number of plates: ", length(unique(meta_processed$Plate_ID))))
if (length(plate_level)==0) {
     (paste0("No plate-level variables."))
     } else {
     print(paste0("Plate-level variables (", length(plate_level_names), "): ", paste(plate_level_names, collapse=", ")))
     print("Unique variable at plate-level:")
     print(meta_processed %>% select(all_of(plate_level_names)) %>% lapply(unique) )
}

print("--- WELL LEVEL SUMMARY ------------------------------------------------------------------------------")
# Searches for any list entry that contains the string "_ID" in the list of "well_level"
# grepl("_ID", well_level)
# print(paste("Well-level variables (", length(well_level), "):", paste(well_level[grepl("_ID", well_level)], collapse=", ")))

# same as above, but now cutting of the last three characters "_ID" through substring(x, 1, nchar(x)-3)
# determine well_level_ids first
# then print the summary
well_level_ids <- substr(well_level_names[grepl("_ID", well_level_names)], 1, nchar(well_level_names[grepl("_ID", well_level_names)])-3)
print(paste0("Well-level variables (", length(well_level_ids), "): ", paste0(well_level_ids, collapse=", "))) 

# show the attributes for each ID
for (i in 1:length(well_level_ids)) {
     print(paste0("Attributes of ", well_level_ids[i], " (", length(well_level_names[grepl(well_level_ids[i], well_level_names)]), "): ", paste0(well_level_names[grepl(well_level_ids[i], well_level_names)], collapse=", "))) 
}

# show factor levels for individual variables
# print(meta_processed %>% summarize_each(funs(distinct))) # efficient counting of all unique per column
# print(meta_processed %>% select(well_level) %>% group_by_at(well_level[1]) %>% summarize()) # this works on a per-column level but not when multiple are selected

# lapply(meta_processed, unique)               # lapply using base R works

# integrating lapply into dplyr
print("Unique variable values at well-level:")
print(meta_processed %>% select(all_of(well_level_names)) %>% lapply(unique) )

as_tibble(meta_processed)

write.csv(meta_processed,"sample_metadata_processed.csv")

```


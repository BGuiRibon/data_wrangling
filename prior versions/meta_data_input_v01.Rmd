---
title: "R Notebook"
output: html_notebook
---

```{r include=FALSE}
require("tidyverse")
```

```{r include=FALSE}



```

Importing data

```{r}
# user input of which file to load
# assign unique experiment ID
# should be included in every plot generated by the script to link output to script and data

setwd("C:/Users/mario/OneDrive - Ribon Therapeutics/R projects/data wrangling")
input_file <- "Bin_metadata"

meta_master <- read_csv(paste0(input_file,".csv"), col_names = FALSE)
meta <- as_tibble(meta_master)

# Validate the presence of Experiment ID

# grepl("Experiment_ID|Experiment ID|Date", meta) # grep and grepl and other functions use regex, "which()" does not

if (length(which(meta=="Experiment_ID"))==0) {
     stop("Experiment_ID not found. Please fix input.")
}

####################################################################################################################
####################################################################################################################
# Search and then confirm Experiment ID -- if no good send back to fix
# Will need to carry Experiment ID along
# Use name_Experiment_ID as variable
# Use 'Experiment_ID to identify header
# Slice of the Experiment_ID column
####################################################################################################################
####################################################################################################################






```
```{r}

# slicing up the data into two parts

# remove all NA rows and columns

meta <- meta[rowSums(is.na(meta)) != ncol(meta),]
meta <- meta[,colSums(is.na(meta)) != nrow(meta)]

# identify entry with 'Experiment_ID'

row <- which(meta=="Experiment_ID", arr.ind = T)[1]
col <- which(meta=="Experiment_ID", arr.ind = T)[2]

# set name of Experiment_ID
Experiment_ID <- toString(meta[row+1,col])


# subset all rows of meta that contain "experiment ID" 
# %in% checks the resulting evaluation of "(meta[,col] == "Experiment_ID" | meta[,col] == Experiment_ID)" and tests if it is TRUE
plates <- meta[(meta[,col] == "Experiment_ID" | meta[,col] == Experiment_ID) %in% TRUE, ]

# subset all rows of meta with the logical inverse of plates
wells <- meta[!((meta[,col] == "Experiment_ID" | meta[,col] == Experiment_ID) %in% TRUE),]



```


```{r eval=FALSE, include=FALSE}

### superseded
### no need to use dplyr
### no need to use join
### no first verifying an specific Experiment_ID entry



# slicing up the data into two parts 
# plates -- includes all information on the plates in the experiment
# vars -- includes all other meta data for the experimental variables

# search for all rows that have any column containing the string plate
# plates <- {meta %>% rowwise() %>% filter(any(str_detect(c_across(), "plate"))) }

# same command but ignoring the case using regex(..., ignore_case = T)
plates <- {
     meta %>% 
     rowwise() %>% 
     filter(any(str_detect(across(), regex("plate", ignore_case = T))))
     }

# meta data are all rows that are not identified as 'plates'
suppressMessages(vars <- anti_join(meta, plates))



# These are various attempts to use dplyr to collapse a row into a list with all non-NA items and reconstruct a df
# turns out it's much easier using base-R


# collapse tibble into list by row
# evaluate tibble by row
# mutate each row individually
# generate new colum with name list_col
# fill list_col (for each row) with output of function 'list' generated across all columns
# c_across refers to column names, across refers to column values

plates1 <- plates %>% rowwise() %>% mutate(list_col=list(!is.na(across()))) # this returns T/F according to logic

# same as above, but properly subsetting across with [] to now remove all NA in one step
# last step selects only list column and passes it to variable

plates2 <- {
     plates %>%
     rowwise() %>%
     mutate(list_col=list(across()[!is.na(across())])) %>%
     select(list_col) }
```


```{r}

# parse the plates section

# --- custom functions ---------------------------------------

ColQuery <- function(prompt) {     
     x = ncol(plates)+1
     while (cols_assigned[x]==TRUE | x > ncol(plates)) {
          x <- as.integer(readline(prompt))
          if(is.na(x)) x=match(FALSE, cols_assigned) # NA means first free column is selected
          if(x < 1) x=ncol(plates)+1
     }
     return(x)
}

# --- custom functions ---------------------------------------

# using apply and na.omit from base R
# collapses everything into a data.frame already
# no need to go via list

# remove NA columns as above
plates <- plates[,colSums(is.na(plates)) != nrow(plates)]

# check for presence of any NA in rows
# rowSums(is.na(plates)) counts NAs per row and puts out a vector
# sum(rowSums) takes the sum of that
# if this is not zero there has to be an NA somewhere
if (sum(rowSums(is.na(plates))) > 0) {
     stop("Plate annotation is incomplete. Missing values can't be interpreted.")
}

# remember for %>% syntax the previous argument gets passed on as the 1st argument of the next function
plates <- {
     plates %>%
     apply(1, na.omit) %>%
     data.frame() %>%
     t() %>%
     data.frame()
}



# convert first row into names and remove
colnames(plates) <- as.character(unlist(plates[1,]))
plates <- plates[-1,]


stop()


# define logical vector to keep track of which column is assigned by what 
cols_assigned <- as.logical(c(rep(FALSE, ncol(plates)), TRUE))

# set up exp, plate, well level data
experiment_level <- vector()
plate_level <- vector()
well_level <- vector()

# call head of current plate to select columns
head(plates)

# figure out which column has the plate ID
q <- ColQuery("Which column holds the plate ID: ")
colnames(plates)[q]="Plate_ID"
cols_assigned[q]=TRUE

# remove all rows that are not unique at Plate_ID
# plates <- plates[ , cols_assigned[1:length(cols_assigned)-1]]
plates <- plates[!duplicated(plates$Plate_ID), ]


# input number of experiment-level variables
q <- -1
while (q < 0 | q > length(cols_assigned[cols_assigned==FALSE])) {
     q <- as.integer(readline("Number of experiment-level variables: "))
     if(is.na(q)) (q=0)
}
n <- q

# loop to assign variable name to column with values
q <- ncol(plates)+1
while (n != 0) {
     while (n !=0 & cols_assigned[q]==TRUE) {
          q <- ColQuery(paste("Column with experiment-level variable (", n, "): "))
          colnames(plates)[q] <- as.character(readline("Name: "))
          # NA/empty means first value in that column is selected
          if (colnames(plates)[q] == "") (colnames(plates)[q] <- as.character(plates[1,q]))
          experiment_level <- c(experiment_level, colnames(plates)[q])
          cols_assigned[q] <- TRUE
          q <- ncol(plates)+1
          n <- n-1
     }
}

# input number of plate-level variables
q <- -1
while (q < 0 | q > length(cols_assigned[cols_assigned==FALSE])) {
     q <- as.integer(readline("Number of plate-level variables: "))
     if (is.na(q)) (q=0)
}
n <- q

# loop to assign variable name to column with values
q <- ncol(plates)+1
while (n != 0) {
     while (n !=0 & cols_assigned[q]==TRUE) {
          q <- ColQuery(paste("Column with plate-level variable (", n, "): "))
          colnames(plates)[q] <- as.character(readline("Name: "))
          # NA/empty means first value in that column is selected
          if (colnames(plates)[q] == "") (colnames(plates)[q] <- as.character(plates[1,q]))
          plate_level <- c(plate_level, colnames(plates)[q])
          cols_assigned[q] <- TRUE
          q <- ncol(plates)+1
          n <- n-1
     }
}

# # fill not assigned column names with DROP and remove
# # stupid complicated
# cols_assigned <- cols_assigned[1:length(cols_assigned)-1]
# colnames(plates)[cols_assigned==FALSE] <- "DROP"
# plates <- plates[ ,colnames(plates)!="DROP"]   

# drop all plates that have unassigned columns
plates <- plates[ , cols_assigned[1:length(cols_assigned)-1]]

# create and insert Plate_No column
plates$Plate_No <- as.numeric(1:nrow(plates))
plates <- plates[ , c(1, ncol(plates), 2:(ncol(plates)-1))]

print(plates)

```


```{r}

# clean up the plate map data and convert into a dataframe

# identify positions of "variable"
variables <- data.frame(which(vars=="variable", arr.ind=TRUE))   # identify x/y of 'variables' 
variables <- variables[order(variables$row),]                    # sort variables table by row

# set up complete dataframe with additional Plate columns
meta_df <- data.frame(Plate_Row = (rep(LETTERS[seq(1:16)],24)), Plate_Col = trunc((seq(1:384)+15)/16), Well_No = c(1:384))

# add column for Well_name (A01-P24)
# Well_Name is concatenation of Plate_Row and Plate_Col
# str_pad adds a leading character ("0") to width (2)

meta_df <- meta_df %>% 
     mutate(Well_Name = paste0(Plate_Row, str_pad(Plate_Col, 2, pad = "0")), Experiment_ID=as.character(name_Experiment_ID)) %>%
# sort by well number
     arrange(Well_No)    

end_row <- 0
for (i in 1:nrow(variables)) {                                   

# empty out dataframe
     slice <- data.frame()
          
# put row/col value of current plate map in row and col
     row <- variables[i,"row"]
     col <- variables[i,"col"]
  
     
# identify variable type, names, and attribute
     type <- vars[row, col+1]
     name <- vars[row+1, col]
     attribute <- vars[row+1, col+1]

# slice out plate based on location of 'variables'
     if  ( i==nrow(variables) ) ( end_row <- nrow(vars) ) else ( end_row <- variables[i+1,"row"]-1 )
     slice <- vars %>% slice((row+2):end_row)

# remove NA rows and NA columns
     slice <- slice[rowSums(is.na(slice)) != ncol(slice),] # remove cols of all NA
     slice <- slice[,colSums(is.na(slice)) != nrow(slice)] # remove rows of all NA     

     values <- unlist(slice, use.names = F)
     length(values)
#     print(head(values))

# append column to meta_df dataframe
     if (type=="numeric") { 
               meta_df <- cbind(meta_df, as.numeric(values))
          } else {
               meta_df <- cbind(meta_df,values)
     }
# add proper metadata to new df column
     names(meta_df)[ncol(meta_df)] <- paste0(name,"_",attribute)
}

# extract well-level variables
well_level <- c(colnames(meta_df[6:ncol(meta_df)]))

```



```{r}

# assemble the full data frame from plate info and plate maps


# copy meta_df in nrows(plates)
meta_df_long <- meta_df

# First reorder the file by plate No 
# Duplicate each row in plates 384x
# not sure what last command 'arrange(across()) does
plates_long <- plates %>% slice(rep(row_number(), 384))

# combine meta_df_long and plates_long
meta_data_df <- cbind(plates_long, meta_df_long)

# sort by plate and well number
# give proper row names to complete file
meta_data_df <- arrange(meta_data_df, Plate_No, Well_No)
row.names(meta_data_df) <- c(seq(1:nrow(meta_data_df)))


# rearrange columns by using relocate
# go via creation of 'new order' vector in case experiment_level or plate_level is empty
# this cause dplyr to throw an error
new_order <- c("Experiment_ID", "Plate_ID", "Plate_No", "Plate_Row", "Plate_Col", "Well_Name", "Well_No", experiment_level[], plate_level[])
meta_data_df <- meta_data_df %>% relocate (new_order[]) 






```


```{r}
# data summary
# When you have the time, redo with cat() and writeLines()
# nest summary properly for displaying unique variables by attribute when calling out the attribute



print("--- EXPERIMENT LEVEL SUMMARY -----------------------------------------------------------------------")
if (length(experiment_level)==0) {
     (paste0("No experiment-level variables."))
     } else {
     print(paste0("Experiment-level variables (", length(experiment_level), "): ", paste(experiment_level, collapse=", "))) 
     print("Unique variable at experiment-level: ")
     print(meta_data_df %>% select(experiment_level) %>% lapply(unique) )
}
     
print("--- PLATE LEVEL SUMMARY -----------------------------------------------------------------------------")
print(paste0("Number of plates: ", length(unique(meta_data_df$Plate_ID))))
if (length(plate_level)==0) {
     (paste0("No plate-level variables."))
     } else {
     print(paste0("Plate-level variables (", length(plate_level), "): ", paste(plate_level, collapse=", ")))
     print("Unique variable at plate-level:")
     print(meta_data_df %>% select(plate_level) %>% lapply(unique) )
}

print("--- WELL LEVEL SUMMARY ------------------------------------------------------------------------------")
# Searches for any list entry that contains the string "_ID" in the list of "well_level"
# grepl("_ID", well_level)
# print(paste("Well-level variables (", length(well_level), "):", paste(well_level[grepl("_ID", well_level)], collapse=", ")))

# same as above, but now cutting of the last three characters "_ID" through substring(x, 1, nchar(x)-3)
# determine well_level_ids first
# then print the summary
well_level_ids <- substr(well_level[grepl("_ID", well_level)], 1, nchar(well_level[grepl("_ID", well_level)])-3)
print(paste0("Well-level variables (", length(well_level_ids), "): ", paste0(well_level_ids, collapse=", "))) 

# show the attributes for each ID
for (i in 1:length(well_level_ids)) {
     print(paste0("Attributes of ", well_level_ids[i], " (", length(well_level[grepl(well_level_ids[i], well_level)]), "): ", paste0(well_level[grepl(well_level_ids[i], well_level)], collapse=", ")))
}

# show factor levels for individual variables
# print(meta_data_df %>% summarize_each(funs(distinct))) # efficient counting of all unique per column
# print(meta_data_df %>% select(well_level) %>% group_by_at(well_level[1]) %>% summarize()) # this works on a per-column level but not when multiple are selected

# lapply(meta_data_df, unique)               # lapply using base R works

# integrating lapply into dplyr
print("Unique variable values at well-level:")
print(meta_data_df %>% select(well_level) %>% lapply(unique) )

tbl_df(meta_data_df)

write.csv(meta_data_df,"sample_metadata_processed.csv")

```
